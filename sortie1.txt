for file in tests/test2.txt tests/test7_IF.txt tests/test4_add_less.txt tests/test6.txt tests/test0.txt tests/test5_echo_mips.txt tests/test3_MIPS.txt tests/test1.txt ; do \
		echo "\033[92m-------------------------------------------------TEST-------------------------------------------------\033[0m" ${file} ; \
		rm -f mips.asm ; \
		if ! ./bin/sos < ${file}  ; then \
			echo "\n\033[91mError in ${file}\033[0m" ; \
			exit 1 ; \
		fi ; \
        done
[92m-------------------------------------------------TEST-------------------------------------------------[0m tests/test2.txt
    mot/id/entier:a
    =
    $
    (
    expr
    mot/id/entier:7
operande_entier-> ENTIER 
ToInt: 7
        cr√©er quadOP:0  cst:7
produit_entier-> operande_entier 
    )
somme_entiere-> produit_entier 
operande-> $ ( EXPR somme_entiere )
concatenation-> operande 
    ;
instruction-> ID = concatenation
        cr√©er quadOP:1  str:a
liste_instruction->instruction
        cr√©er quadOP:2  cst:0
    mot/id/entier:b
    =
    $
    (
    expr
    mot/id/entier:5
operande_entier-> ENTIER 
ToInt: 5
        cr√©er quadOP:3  cst:5
produit_entier-> operande_entier 
    /
    mot/id/entier:4
operande_entier-> ENTIER 
ToInt: 4
        cr√©er quadOP:4  cst:4
produit_entier-> produit_entier fois_div_mod operande_entier
        cr√©er quadOP:5  str:__TEMP__1
    *
    mot/id/entier:8
operande_entier-> ENTIER 
ToInt: 8
        cr√©er quadOP:6  cst:8
produit_entier-> produit_entier fois_div_mod operande_entier
        cr√©er quadOP:7  str:__TEMP__2
    +
somme_entiere-> produit_entier 
    $
    {
    mot/id/entier:a
    }
operande_entier-> $ { id } 
        cr√©er quadOP:8  str:a
produit_entier-> operande_entier 
    )
somme_entiere-> somme_entiere plus_ou_moin produit_entier 
        cr√©er quadOP:9  str:__TEMP__3
operande-> $ ( EXPR somme_entiere )
concatenation-> operande 
    ;
instruction-> ID = concatenation
        cr√©er quadOP:10  str:b
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:11  cst:0
    exit
instruction->EXIT
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:12  cst:0
programme->liste_instruction

Affichage Lglobal:
ligne 1:  res: id:a  EQUAL  op1: cst:7  op2: NULL 
ligne 2:  res: addr:3  GOTO  op1: NULL  op2: NULL 
ligne 3:  res: id:__TEMP__1  DIV  op1: cst:5  op2: cst:4 
ligne 4:  res: id:__TEMP__2  MUL  op1: id:__TEMP__1  op2: cst:8 
ligne 5:  res: id:__TEMP__3  ADD  op1: id:__TEMP__2  op2: id:a 
ligne 6:  res: id:b  EQUAL  op1: id:__TEMP__3  op2: NULL 
ligne 7:  res: addr:8  GOTO  op1: NULL  op2: NULL 
ligne 8:  res: NULL  EXIT  op1: NULL  op2: NULL 
ligne 9:  res: addr:10  GOTO  op1: NULL  op2: NULL 
Yacc return : ->0

### MIPS: ###

 EQUAL 
 GOTO 
 DIV 
 MUL 
 ADD 
 EQUAL 
 GOTO 
 EXIT 
 GOTO 

### Table of symbols : ###

n¬∞29810 : ID			Type : int      	a
n¬∞29811 : ID			Type : int      	b

Free Lglobal:


[92m-------------------------------------------------TEST-------------------------------------------------[0m tests/test7_IF.txt
    mot/id/entier:i
    =
    mot/id/entier:2
operande-> MOT
        cr√©er quadOP:0  str:2
concatenation-> operande 
    ;
instruction-> ID = concatenation
        cr√©er quadOP:1  str:i
liste_instruction->instruction
        cr√©er quadOP:2  cst:0
    mot/id/entier:k
    =
    mot/id/entier:2
operande-> MOT
        cr√©er quadOP:3  str:2
concatenation-> operande 
    ;
instruction-> ID = concatenation
        cr√©er quadOP:4  str:k
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:5  cst:0
    if
    test
    $
    {
    mot/id/entier:i
    }
operande-> $ { ID }
        cr√©er quadOP:6  str:i
    =
concatenation-> operande 
    $
    {
    mot/id/entier:k
    }
operande-> $ { ID }
        cr√©er quadOP:7  str:k
concatenation-> operande 
    then
test_instruction-> concatenation = concatenation 
        cr√©er quadOP:8  str:__TEMP__1
test_expr3 -> test_instruction 
test_expr2-> test_expr3 
2
3
test_expr-> test_expr2 
test_bloc-> TEST test_expr 
M->empty
    mot/id/entier:i
    =
    mot/id/entier:3
operande-> MOT
        cr√©er quadOP:9  str:3
concatenation-> operande 
    else
instruction-> ID = concatenation
        cr√©er quadOP:10  str:i
liste_instruction->instruction
        cr√©er quadOP:11  cst:0
M->empty
    mot/id/entier:k
    =
    mot/id/entier:4
operande-> MOT
        cr√©er quadOP:12  str:4
concatenation-> operande 
    fi
instruction-> ID = concatenation
        cr√©er quadOP:13  str:k
liste_instruction->instruction
        cr√©er quadOP:14  cst:0
else_part->ELSE liste_instructions
instruction-> IF test_bloc THEN liste_instructions else_part FI 
        cr√©er quadOP:15  cst:8
        cr√©er quadOP:16  cst:10
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:17  cst:0
    ;
    echo
    $
    {
    mot/id/entier:i
    }
operande-> $ { ID }
        cr√©er quadOP:18  str:i
liste_operandes-> operande 
        cr√©er quadOP:19  cst:1
        cr√©er quadOP:20  str:$
    ;
instruction-> MYECHO liste_operandes 
        cr√©er quadOP:21  cst:1
        cr√©er quadOP:22  str:$
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:23  cst:0
    if
    test
    $
    {
    mot/id/entier:i
    }
operande-> $ { ID }
        cr√©er quadOP:24  str:i
    ?
concatenation-> operande 
    =
    $
    {
    mot/id/entier:k
    }
operande-> $ { ID }
        cr√©er quadOP:25  str:k
concatenation-> operande 
    then
test_instruction-> concatenation != concatenation 
        cr√©er quadOP:26  str:__TEMP__2
test_expr3 -> test_instruction 
test_expr2-> test_expr3 
2
3
test_expr-> test_expr2 
test_bloc-> TEST test_expr 
M->empty
    mot/id/entier:i
    =
    mot/id/entier:3
operande-> MOT
        cr√©er quadOP:27  str:3
concatenation-> operande 
    else
instruction-> ID = concatenation
        cr√©er quadOP:28  str:i
liste_instruction->instruction
        cr√©er quadOP:29  cst:0
M->empty
    mot/id/entier:k
    =
    mot/id/entier:4
operande-> MOT
        cr√©er quadOP:30  str:4
concatenation-> operande 
    fi
instruction-> ID = concatenation
        cr√©er quadOP:31  str:k
liste_instruction->instruction
        cr√©er quadOP:32  cst:0
else_part->ELSE liste_instructions
instruction-> IF test_bloc THEN liste_instructions else_part FI 
        cr√©er quadOP:33  cst:19
        cr√©er quadOP:34  cst:21
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:35  cst:0
    ;
    if
    test
    $
    {
    mot/id/entier:i
    }
operande-> $ { ID }
        cr√©er quadOP:36  str:i
    -lt
operateur2-> -lt
    $
    {
    mot/id/entier:k
    }
operande-> $ { ID }
        cr√©er quadOP:37  str:k
test_instruction-> operande operateur2 operande 
        cr√©er quadOP:38  str:__TEMP__3
test_expr3 -> test_instruction 
test_expr2-> test_expr3 
2
3
    then
test_expr-> test_expr2 
test_bloc-> TEST test_expr 
M->empty
    mot/id/entier:i
    =
    mot/id/entier:3
operande-> MOT
        cr√©er quadOP:39  str:3
concatenation-> operande 
    else
instruction-> ID = concatenation
        cr√©er quadOP:40  str:i
liste_instruction->instruction
        cr√©er quadOP:41  cst:0
M->empty
    mot/id/entier:k
    =
    mot/id/entier:4
operande-> MOT
        cr√©er quadOP:42  str:4
concatenation-> operande 
    fi
instruction-> ID = concatenation
        cr√©er quadOP:43  str:k
liste_instruction->instruction
        cr√©er quadOP:44  cst:0
else_part->ELSE liste_instructions
instruction-> IF test_bloc THEN liste_instructions else_part FI 
        cr√©er quadOP:45  cst:27
        cr√©er quadOP:46  cst:29
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:47  cst:0
    ;
    exit
instruction->EXIT
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:48  cst:0
programme->liste_instruction

Affichage Lglobal:
ligne 1:  res: id:i  EQUAL  op1: string:2  op2: NULL 
ligne 2:  res: addr:3  GOTO  op1: NULL  op2: NULL 
ligne 3:  res: id:k  EQUAL  op1: string:2  op2: NULL 
ligne 4:  res: addr:5  GOTO  op1: NULL  op2: NULL 
ligne 5:  res: id:__TEMP__1  IF ==  op1: id:i  op2: id:k 
ligne 6:  res: addr:8  IF _ GOTO  op1: id:__TEMP__1  op2: NULL 
ligne 7:  res: addr:10  GOTO  op1: NULL  op2: NULL 
ligne 8:  res: id:i  EQUAL  op1: string:3  op2: NULL 
ligne 9:  res: addr:10  GOTO  op1: NULL  op2: NULL 
ligne 10:  res: id:k  EQUAL  op1: string:4  op2: NULL 
ligne 11:  res: addr:12  GOTO  op1: NULL  op2: NULL 
ligne 12:  res: addr:13  GOTO  op1: NULL  op2: NULL 
ligne 13:  res: tab:$  TAB[]EQUAL  op1: cst:1  op2: id:i 
ligne 14:  res: tab:$  ECHO  op1: cst:1  op2: NULL 
ligne 15:  res: addr:16  GOTO  op1: NULL  op2: NULL 
ligne 16:  res: id:__TEMP__2  IF !=  op1: id:i  op2: id:k 
ligne 17:  res: addr:19  IF _ GOTO  op1: id:__TEMP__2  op2: NULL 
ligne 18:  res: addr:21  GOTO  op1: NULL  op2: NULL 
ligne 19:  res: id:i  EQUAL  op1: string:3  op2: NULL 
ligne 20:  res: addr:21  GOTO  op1: NULL  op2: NULL 
ligne 21:  res: id:k  EQUAL  op1: string:4  op2: NULL 
ligne 22:  res: addr:23  GOTO  op1: NULL  op2: NULL 
ligne 23:  res: addr:24  GOTO  op1: NULL  op2: NULL 
ligne 24:  res: id:__TEMP__3  IF <  op1: id:i  op2: id:k 
ligne 25:  res: addr:27  IF _ GOTO  op1: id:__TEMP__3  op2: NULL 
ligne 26:  res: addr:29  GOTO  op1: NULL  op2: NULL 
ligne 27:  res: id:i  EQUAL  op1: string:3  op2: NULL 
ligne 28:  res: addr:29  GOTO  op1: NULL  op2: NULL 
ligne 29:  res: id:k  EQUAL  op1: string:4  op2: NULL 
ligne 30:  res: addr:31  GOTO  op1: NULL  op2: NULL 
ligne 31:  res: addr:32  GOTO  op1: NULL  op2: NULL 
ligne 32:  res: NULL  EXIT  op1: NULL  op2: NULL 
ligne 33:  res: addr:34  GOTO  op1: NULL  op2: NULL 
Yacc return : ->0

### MIPS: ###

 EQUAL 
 GOTO 
 EQUAL 
 GOTO 
 IF == 
 IF _ GOTO 
 GOTO 
 EQUAL 
 GOTO 
 EQUAL 
 GOTO 
 GOTO 
 TAB[]EQUAL 
 ECHO 
 GOTO 
 IF != 
 IF _ GOTO 
 GOTO 
 EQUAL 
 GOTO 
 EQUAL 
 GOTO 
 GOTO 
 IF < 
 IF _ GOTO 
 GOTO 
 EQUAL 
 GOTO 
 EQUAL 
 GOTO 
 GOTO 
 EXIT 
 GOTO 

### Table of symbols : ###

n¬∞29818 : ID			Type : string      	i
n¬∞29820 : ID			Type : string      	k

Free Lglobal:


[92m-------------------------------------------------TEST-------------------------------------------------[0m tests/test4_add_less.txt
    mot/id/entier:i
    =
    mot/id/entier:8
operande-> MOT
        cr√©er quadOP:0  str:8
concatenation-> operande 
    ;
instruction-> ID = concatenation
        cr√©er quadOP:1  str:i
liste_instruction->instruction
        cr√©er quadOP:2  cst:0
    mot/id/entier:c
    =
    mot/id/entier:4
operande-> MOT
        cr√©er quadOP:3  str:4
concatenation-> operande 
    ;
instruction-> ID = concatenation
        cr√©er quadOP:4  str:c
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:5  cst:0
    mot/id/entier:var2
    =
    $
    (
    expr
    mot/id/entier:1
operande_entier-> ENTIER 
ToInt: 1
        cr√©er quadOP:6  cst:1
produit_entier-> operande_entier 
    +
somme_entiere-> produit_entier 
    mot/id/entier:2
operande_entier-> ENTIER 
ToInt: 2
        cr√©er quadOP:7  cst:2
produit_entier-> operande_entier 
    )
somme_entiere-> somme_entiere plus_ou_moin produit_entier 
        cr√©er quadOP:8  str:__TEMP__1
operande-> $ ( EXPR somme_entiere )
concatenation-> operande 
    ;
instruction-> ID = concatenation
        cr√©er quadOP:9  str:var2
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:10  cst:0
    mot/id/entier:var1
    =
    $
    (
    expr
    $
    {
    mot/id/entier:i
    }
operande_entier-> $ { id } 
        cr√©er quadOP:11  str:i
produit_entier-> operande_entier 
    -
somme_entiere-> produit_entier 
    mot/id/entier:4
operande_entier-> ENTIER 
ToInt: 4
        cr√©er quadOP:12  cst:4
produit_entier-> operande_entier 
    )
somme_entiere-> somme_entiere plus_ou_moin produit_entier 
        cr√©er quadOP:13  str:__TEMP__2
operande-> $ ( EXPR somme_entiere )
concatenation-> operande 
    ;
instruction-> ID = concatenation
        cr√©er quadOP:14  str:var1
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:15  cst:0
    mot/id/entier:v
    =
    $
    (
    expr
    $
    {
    mot/id/entier:var1
    }
operande_entier-> $ { id } 
        cr√©er quadOP:16  str:var1
produit_entier-> operande_entier 
    +
somme_entiere-> produit_entier 
    mot/id/entier:4
operande_entier-> ENTIER 
ToInt: 4
        cr√©er quadOP:17  cst:4
produit_entier-> operande_entier 
    )
somme_entiere-> somme_entiere plus_ou_moin produit_entier 
        cr√©er quadOP:18  str:__TEMP__3
operande-> $ ( EXPR somme_entiere )
concatenation-> operande 
    ;
instruction-> ID = concatenation
        cr√©er quadOP:19  str:v
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:20  cst:0
    mot/id/entier:p
    =
    $
    (
    expr
    $
    {
    mot/id/entier:v
    }
operande_entier-> $ { id } 
        cr√©er quadOP:21  str:v
produit_entier-> operande_entier 
    +
somme_entiere-> produit_entier 
    $
    {
    mot/id/entier:i
    }
operande_entier-> $ { id } 
        cr√©er quadOP:22  str:i
produit_entier-> operande_entier 
    )
somme_entiere-> somme_entiere plus_ou_moin produit_entier 
        cr√©er quadOP:23  str:__TEMP__4
operande-> $ ( EXPR somme_entiere )
concatenation-> operande 
    ;
instruction-> ID = concatenation
        cr√©er quadOP:24  str:p
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:25  cst:0
    mot/id/entier:w
    =
    $
    (
    expr
    $
    {
    mot/id/entier:v
    }
operande_entier-> $ { id } 
        cr√©er quadOP:26  str:v
produit_entier-> operande_entier 
    -
somme_entiere-> produit_entier 
    $
    {
    mot/id/entier:p
    }
operande_entier-> $ { id } 
        cr√©er quadOP:27  str:p
produit_entier-> operande_entier 
    )
somme_entiere-> somme_entiere plus_ou_moin produit_entier 
        cr√©er quadOP:28  str:__TEMP__5
operande-> $ ( EXPR somme_entiere )
concatenation-> operande 
    ;
instruction-> ID = concatenation
        cr√©er quadOP:29  str:w
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:30  cst:0
    mot/id/entier:x
    =
    $
    (
    expr
    $
    {
    mot/id/entier:w
    }
operande_entier-> $ { id } 
        cr√©er quadOP:31  str:w
produit_entier-> operande_entier 
    -
somme_entiere-> produit_entier 
    $
    {
    mot/id/entier:p
    }
operande_entier-> $ { id } 
        cr√©er quadOP:32  str:p
produit_entier-> operande_entier 
    )
somme_entiere-> somme_entiere plus_ou_moin produit_entier 
        cr√©er quadOP:33  str:__TEMP__6
operande-> $ ( EXPR somme_entiere )
concatenation-> operande 
    ;
instruction-> ID = concatenation
        cr√©er quadOP:34  str:x
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:35  cst:0
    mot/id/entier:y
    =
    $
    (
    expr
    $
    {
    mot/id/entier:x
    }
operande_entier-> $ { id } 
        cr√©er quadOP:36  str:x
produit_entier-> operande_entier 
    -
somme_entiere-> produit_entier 
    $
    {
    mot/id/entier:p
    }
operande_entier-> $ { id } 
        cr√©er quadOP:37  str:p
produit_entier-> operande_entier 
    )
somme_entiere-> somme_entiere plus_ou_moin produit_entier 
        cr√©er quadOP:38  str:__TEMP__7
operande-> $ ( EXPR somme_entiere )
concatenation-> operande 
    ;
instruction-> ID = concatenation
        cr√©er quadOP:39  str:y
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:40  cst:0
    mot/id/entier:z
    =
    $
    (
    expr
    $
    {
    mot/id/entier:y
    }
operande_entier-> $ { id } 
        cr√©er quadOP:41  str:y
produit_entier-> operande_entier 
    -
somme_entiere-> produit_entier 
    $
    {
    mot/id/entier:p
    }
operande_entier-> $ { id } 
        cr√©er quadOP:42  str:p
produit_entier-> operande_entier 
    )
somme_entiere-> somme_entiere plus_ou_moin produit_entier 
        cr√©er quadOP:43  str:__TEMP__8
operande-> $ ( EXPR somme_entiere )
concatenation-> operande 
    ;
instruction-> ID = concatenation
        cr√©er quadOP:44  str:z
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:45  cst:0
    exit
instruction->EXIT
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:46  cst:0
programme->liste_instruction

Affichage Lglobal:
ligne 1:  res: id:i  EQUAL  op1: string:8  op2: NULL 
ligne 2:  res: addr:3  GOTO  op1: NULL  op2: NULL 
ligne 3:  res: id:c  EQUAL  op1: string:4  op2: NULL 
ligne 4:  res: addr:5  GOTO  op1: NULL  op2: NULL 
ligne 5:  res: id:__TEMP__1  ADD  op1: cst:1  op2: cst:2 
ligne 6:  res: id:var2  EQUAL  op1: id:__TEMP__1  op2: NULL 
ligne 7:  res: addr:8  GOTO  op1: NULL  op2: NULL 
ligne 8:  res: id:__TEMP__2  LESS  op1: id:i  op2: cst:4 
ligne 9:  res: id:var1  EQUAL  op1: id:__TEMP__2  op2: NULL 
ligne 10:  res: addr:11  GOTO  op1: NULL  op2: NULL 
ligne 11:  res: id:__TEMP__3  ADD  op1: id:var1  op2: cst:4 
ligne 12:  res: id:v  EQUAL  op1: id:__TEMP__3  op2: NULL 
ligne 13:  res: addr:14  GOTO  op1: NULL  op2: NULL 
ligne 14:  res: id:__TEMP__4  ADD  op1: id:v  op2: id:i 
ligne 15:  res: id:p  EQUAL  op1: id:__TEMP__4  op2: NULL 
ligne 16:  res: addr:17  GOTO  op1: NULL  op2: NULL 
ligne 17:  res: id:__TEMP__5  LESS  op1: id:v  op2: id:p 
ligne 18:  res: id:w  EQUAL  op1: id:__TEMP__5  op2: NULL 
ligne 19:  res: addr:20  GOTO  op1: NULL  op2: NULL 
ligne 20:  res: id:__TEMP__6  LESS  op1: id:w  op2: id:p 
ligne 21:  res: id:x  EQUAL  op1: id:__TEMP__6  op2: NULL 
ligne 22:  res: addr:23  GOTO  op1: NULL  op2: NULL 
ligne 23:  res: id:__TEMP__7  LESS  op1: id:x  op2: id:p 
ligne 24:  res: id:y  EQUAL  op1: id:__TEMP__7  op2: NULL 
ligne 25:  res: addr:26  GOTO  op1: NULL  op2: NULL 
ligne 26:  res: id:__TEMP__8  LESS  op1: id:y  op2: id:p 
ligne 27:  res: id:z  EQUAL  op1: id:__TEMP__8  op2: NULL 
ligne 28:  res: addr:29  GOTO  op1: NULL  op2: NULL 
ligne 29:  res: NULL  EXIT  op1: NULL  op2: NULL 
ligne 30:  res: addr:31  GOTO  op1: NULL  op2: NULL 
Yacc return : ->0

### MIPS: ###

 EQUAL 
 GOTO 
 EQUAL 
 GOTO 
 ADD 
 EQUAL 
 GOTO 
 LESS 
 EQUAL 
 GOTO 
 ADD 
 EQUAL 
 GOTO 
 ADD 
 EQUAL 
 GOTO 
 LESS 
 EQUAL 
 GOTO 
 LESS 
 EQUAL 
 GOTO 
 LESS 
 EQUAL 
 GOTO 
 LESS 
 EQUAL 
 GOTO 
 EXIT 
 GOTO 

### Table of symbols : ###

n¬∞29812 : ID			Type : string      	c
n¬∞29818 : ID			Type : int      	i
n¬∞29825 : ID			Type : int      	p
n¬∞29831 : ID			Type : int      	v
n¬∞29832 : ID			Type : int      	w
n¬∞29833 : ID			Type : int      	x
n¬∞29834 : ID			Type : int      	y
n¬∞29835 : ID			Type : int      	z
n¬∞78795 : ID			Type : int      	var1
n¬∞78796 : ID			Type : int      	var2

Free Lglobal:


[92m-------------------------------------------------TEST-------------------------------------------------[0m tests/test6.txt
    declare
    mot/id/entier:tableau
    [
    mot/id/entier:5
    ]
instruction-> DECLARE ID [ ENTIER ] 
ToInt: 5
        cr√©er quadOP:0  str:tableau
        cr√©er quadOP:1  cst:5
liste_instruction->instruction
        cr√©er quadOP:2  cst:0
    ;
    mot/id/entier:tableau
    [
    mot/id/entier:1
operande_entier-> ENTIER 
ToInt: 1
        cr√©er quadOP:3  cst:1
    ]
    =
    mot/id/entier:6
operande-> MOT
        cr√©er quadOP:4  str:6
concatenation-> operande 
    ;
instruction-> ID [ operande_entier ] = concatenation
        cr√©er quadOP:5  str:tableau
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:6  cst:0
    mot/id/entier:tableau
    [
    mot/id/entier:2
operande_entier-> ENTIER 
ToInt: 2
        cr√©er quadOP:7  cst:2
    ]
    =
    mot/id/entier:1
operande-> MOT
        cr√©er quadOP:8  str:1
concatenation-> operande 
    ;
instruction-> ID [ operande_entier ] = concatenation
        cr√©er quadOP:9  str:tableau
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:10  cst:0
    mot/id/entier:tableau
    [
    mot/id/entier:3
operande_entier-> ENTIER 
ToInt: 3
        cr√©er quadOP:11  cst:3
    ]
    =
    mot/id/entier:6
operande-> MOT
        cr√©er quadOP:12  str:6
concatenation-> operande 
    ;
instruction-> ID [ operande_entier ] = concatenation
        cr√©er quadOP:13  str:tableau
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:14  cst:0
    mot/id/entier:tableau
    [
    mot/id/entier:4
operande_entier-> ENTIER 
ToInt: 4
        cr√©er quadOP:15  cst:4
    ]
    =
    mot/id/entier:2
operande-> MOT
        cr√©er quadOP:16  str:2
concatenation-> operande 
    ;
instruction-> ID [ operande_entier ] = concatenation
        cr√©er quadOP:17  str:tableau
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:18  cst:0
    mot/id/entier:tableau
    [
    mot/id/entier:5
operande_entier-> ENTIER 
ToInt: 5
        cr√©er quadOP:19  cst:5
    ]
    =
    mot/id/entier:5
operande-> MOT
        cr√©er quadOP:20  str:5
concatenation-> operande 
    ;
instruction-> ID [ operande_entier ] = concatenation
        cr√©er quadOP:21  str:tableau
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:22  cst:0
    echo
    $
    {
    mot/id/entier:tableau
    [
    *
    ]
    }
liste_operandes-> $ { ID [ * ] } 
        cr√©er quadOP:23  str:__TEMP__1
        cr√©er quadOP:24  str:$
        cr√©er quadOP:25  str:tableau
        cr√©er quadOP:26  cst:0
    ;
instruction-> MYECHO liste_operandes 
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:27  cst:0
    exit
instruction->EXIT
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:28  cst:0
programme->liste_instruction

Affichage Lglobal:
ligne 1:  res: tab:tableau  TAB[]CREAT  op1: cst:5  op2: NULL 
ligne 2:  res: addr:3  GOTO  op1: NULL  op2: NULL 
ligne 3:  res: tab:tableau  TAB[]EQUAL  op1: cst:1  op2: string:6 
ligne 4:  res: addr:5  GOTO  op1: NULL  op2: NULL 
ligne 5:  res: tab:tableau  TAB[]EQUAL  op1: cst:2  op2: string:1 
ligne 6:  res: addr:7  GOTO  op1: NULL  op2: NULL 
ligne 7:  res: tab:tableau  TAB[]EQUAL  op1: cst:3  op2: string:6 
ligne 8:  res: addr:9  GOTO  op1: NULL  op2: NULL 
ligne 9:  res: tab:tableau  TAB[]EQUAL  op1: cst:4  op2: string:2 
ligne 10:  res: addr:11  GOTO  op1: NULL  op2: NULL 
ligne 11:  res: tab:tableau  TAB[]EQUAL  op1: cst:5  op2: string:5 
ligne 12:  res: addr:13  GOTO  op1: NULL  op2: NULL 
ligne 13:  res: id:__TEMP__1  TAB[]GIVE  op1: tab:tableau  op2: cst:0 
ligne 14:  res: tab:$  TAB[]EQUAL  op1: cst:0  op2: id:__TEMP__1 
ligne 15:  res: addr:16  GOTO  op1: NULL  op2: NULL 
ligne 16:  res: NULL  EXIT  op1: NULL  op2: NULL 
ligne 17:  res: addr:18  GOTO  op1: NULL  op2: NULL 
Yacc return : ->0

### MIPS: ###

 TAB[]CREAT 
 GOTO 
 TAB[]EQUAL 
 GOTO 
 TAB[]EQUAL 
 GOTO 
 TAB[]EQUAL 
 GOTO 
 TAB[]EQUAL 
 GOTO 
 TAB[]EQUAL 
 GOTO 
 TAB[]GIVE 
 TAB[]EQUAL 
 GOTO 
 EXIT 
 GOTO 

### Table of symbols : ###

n¬∞3215 : ID			Type : undefined	tableau

Free Lglobal:


[92m-------------------------------------------------TEST-------------------------------------------------[0m tests/test0.txt
    commentaire
    declare
    mot/id/entier:valeurs
    [
    mot/id/entier:4
    ]
instruction-> DECLARE ID [ ENTIER ] 
ToInt: 4
        cr√©er quadOP:0  str:valeurs
        cr√©er quadOP:1  cst:4
liste_instruction->instruction
        cr√©er quadOP:2  cst:0
    ;
    mot/id/entier:lecture_valeurs
    (
    )
dec_fct->empty
    commentaire
    {
decl_loc-> empty 
    local
    mot/id/entier:i
    =
    mot/id/entier:0
operande-> MOT
        cr√©er quadOP:3  str:0
concatenation-> operande 
    ;
decl_loc-> decl_loc LOCAL id = concatenation 
        cr√©er quadOP:4  str:i
    local
    mot/id/entier:nombre
    =
    $
    mot/id/entier:1
operande-> $ ENTIER
ToInt: 1
        cr√©er quadOP:5  str:$1
concatenation-> operande 
    ;
decl_loc-> decl_loc LOCAL id = concatenation 
        cr√©er quadOP:6  str:nombre
    echo
    chaine:"Il faut saisir "
operande-> CHAINE:"Il faut saisir "
        cr√©er quadOP:7  str:"Il faut saisir "
liste_operandes-> operande 
        cr√©er quadOP:8  cst:1
        cr√©er quadOP:9  str:$
    $
    mot/id/entier:1
operande-> $ ENTIER
ToInt: 1
        cr√©er quadOP:10  str:$1
liste_operandes-> liste_operandes operande 
        cr√©er quadOP:11  cst:2
        cr√©er quadOP:12  str:$
    chaine:"valeurs entieres\n"
operande-> CHAINE:"valeurs entieres\n"
        cr√©er quadOP:13  str:"valeurs entieres\n"
liste_operandes-> liste_operandes operande 
        cr√©er quadOP:14  cst:3
        cr√©er quadOP:15  str:$
    ;
instruction-> MYECHO liste_operandes 
        cr√©er quadOP:16  cst:1
        cr√©er quadOP:17  str:$
        cr√©er quadOP:18  cst:2
        cr√©er quadOP:19  str:$
        cr√©er quadOP:20  cst:3
        cr√©er quadOP:21  str:$
liste_instruction->instruction
        cr√©er quadOP:22  cst:0
    while
M->empty
    test
    $
    {
    mot/id/entier:i
    }
operande-> $ { ID }
        cr√©er quadOP:23  str:i
    -lt
operateur2-> -lt
    $
    {
    mot/id/entier:nombre
    }
operande-> $ { ID }
        cr√©er quadOP:24  str:nombre
test_instruction-> operande operateur2 operande 
        cr√©er quadOP:25  str:__TEMP__1
test_expr3 -> test_instruction 
test_expr2-> test_expr3 
2
3
    do
test_expr-> test_expr2 
test_bloc-> TEST test_expr 
M->empty
    echo
    chaine:"Entrez la valeur "
operande-> CHAINE:"Entrez la valeur "
        cr√©er quadOP:26  str:"Entrez la valeur "
liste_operandes-> operande 
        cr√©er quadOP:27  cst:1
        cr√©er quadOP:28  str:$
    $
    (
    expr
    $
    {
    mot/id/entier:i
    }
operande_entier-> $ { id } 
        cr√©er quadOP:29  str:i
produit_entier-> operande_entier 
    +
somme_entiere-> produit_entier 
    mot/id/entier:1
operande_entier-> ENTIER 
ToInt: 1
        cr√©er quadOP:30  cst:1
produit_entier-> operande_entier 
    )
somme_entiere-> somme_entiere plus_ou_moin produit_entier 
        cr√©er quadOP:31  str:__TEMP__2
operande-> $ ( EXPR somme_entiere )
liste_operandes-> liste_operandes operande 
        cr√©er quadOP:32  cst:2
        cr√©er quadOP:33  str:$
    chaine:" : \n"
operande-> CHAINE:" : \n"
        cr√©er quadOP:34  str:" : \n"
liste_operandes-> liste_operandes operande 
        cr√©er quadOP:35  cst:3
        cr√©er quadOP:36  str:$
    ;
instruction-> MYECHO liste_operandes 
        cr√©er quadOP:37  cst:1
        cr√©er quadOP:38  str:$
        cr√©er quadOP:39  cst:2
        cr√©er quadOP:40  str:$
        cr√©er quadOP:41  cst:3
        cr√©er quadOP:42  str:$
liste_instruction->instruction
        cr√©er quadOP:43  cst:0
    read
    mot/id/entier:valeurs
    [
    $
    {
    mot/id/entier:i
    }
operande_entier-> $ { id } 
        cr√©er quadOP:44  str:i
    ]
instruction-> READ ID [ operande_entier ] 
        cr√©er quadOP:45  str:valeurs
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:46  cst:0
    ;
    if
    test
    ?
    $
    {
    mot/id/entier:valeurs
    [
    $
    {
    mot/id/entier:i
    }
operande_entier-> $ { id } 
        cr√©er quadOP:47  str:i
    ]
    }
operande-> $ { id [ operande_entier ] }
        cr√©er quadOP:48  str:valeurs
        cr√©er quadOP:49  str:__TEMP__3
    -gt
operateur2-> -gt
    mot/id/entier:0
operande-> MOT
        cr√©er quadOP:50  str:0
test_instruction-> operande operateur2 operande 
        cr√©er quadOP:51  str:__TEMP__4
test_expr3-> ! test_instruction 
        cr√©er quadOP:52  str:__TEMP__5
test_expr2-> test_expr3 
2
3
    then
test_expr-> test_expr2 
test_bloc-> TEST test_expr 
M->empty
    echo
    chaine:"Les valeurs doivent etre strictement positives !\n"
operande-> CHAINE:"Les valeurs doivent etre strictement positives !\n"
        cr√©er quadOP:53  str:"Les valeurs doivent etre strictement positives !\n"
liste_operandes-> operande 
        cr√©er quadOP:54  cst:1
        cr√©er quadOP:55  str:$
    ;
instruction-> MYECHO liste_operandes 
        cr√©er quadOP:56  cst:1
        cr√©er quadOP:57  str:$
liste_instruction->instruction
        cr√©er quadOP:58  cst:0
    return
    mot/id/entier:1
operande_entier-> ENTIER 
ToInt: 1
        cr√©er quadOP:59  cst:1
instruction-> RETURN operande_entier 
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:60  cst:0
    fi
M->empty
else_part->empty
instruction-> IF test_bloc THEN liste_instructions else_part FI 
        cr√©er quadOP:61  cst:31
        cr√©er quadOP:62  cst:36
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:63  cst:0
    ;
    mot/id/entier:i
    =
    $
    (
    expr
    $
    {
    mot/id/entier:i
    }
operande_entier-> $ { id } 
        cr√©er quadOP:64  str:i
produit_entier-> operande_entier 
    +
somme_entiere-> produit_entier 
    mot/id/entier:1
operande_entier-> ENTIER 
ToInt: 1
        cr√©er quadOP:65  cst:1
produit_entier-> operande_entier 
    )
somme_entiere-> somme_entiere plus_ou_moin produit_entier 
        cr√©er quadOP:66  str:__TEMP__6
operande-> $ ( EXPR somme_entiere )
concatenation-> operande 
    done
instruction-> ID = concatenation
        cr√©er quadOP:67  str:i
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:68  cst:0
M->empty
instruction-> WHILE test_bloc DO liste_instructions DONE 
        cr√©er quadOP:69  cst:16
        cr√©er quadOP:70  cst:40
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:71  cst:0
    ;
    return
    mot/id/entier:0
operande_entier-> ENTIER 
ToInt: 0
        cr√©er quadOP:72  cst:0
instruction-> RETURN operande_entier 
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:73  cst:0
    }
declaration_de_fonction-> id ( ) { decl_loc liste_instructions }
        cr√©er quadOP:74  str:lecture_valeurs
instruction-> declaration_de_fonction 
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:75  cst:0
    ;
    mot/id/entier:moyenne
    (
    )
dec_fct->empty
    {
decl_loc-> empty 
    commentaire
    local
    mot/id/entier:i
    =
    mot/id/entier:0
operande-> MOT
        cr√©er quadOP:76  str:0
concatenation-> operande 
    ;
decl_loc-> decl_loc LOCAL id = concatenation 
        cr√©er quadOP:77  str:i
    local
    mot/id/entier:somme
    =
    mot/id/entier:0
operande-> MOT
        cr√©er quadOP:78  str:0
concatenation-> operande 
    ;
decl_loc-> decl_loc LOCAL id = concatenation 
        cr√©er quadOP:79  str:somme
    while
M->empty
    test
    $
    {
    mot/id/entier:i
    }
operande-> $ { ID }
        cr√©er quadOP:80  str:i
    -lt
operateur2-> -lt
    $
    mot/id/entier:1
operande-> $ ENTIER
ToInt: 1
        cr√©er quadOP:81  str:$1
test_instruction-> operande operateur2 operande 
        cr√©er quadOP:82  str:__TEMP__7
test_expr3 -> test_instruction 
test_expr2-> test_expr3 
2
3
    do
test_expr-> test_expr2 
test_bloc-> TEST test_expr 
M->empty
    mot/id/entier:somme
    =
    $
    (
    expr
    $
    {
    mot/id/entier:somme
    }
operande_entier-> $ { id } 
        cr√©er quadOP:83  str:somme
produit_entier-> operande_entier 
    +
somme_entiere-> produit_entier 
    $
    {
    mot/id/entier:valeurs
    [
    $
    {
    mot/id/entier:i
    }
operande_entier-> $ { id } 
        cr√©er quadOP:84  str:i
    ]
    }
operande_entier-> $ { id [ operande_entier ] } 
        cr√©er quadOP:85  str:valeurs
        cr√©er quadOP:86  str:__TEMP__8
produit_entier-> operande_entier 
    )
somme_entiere-> somme_entiere plus_ou_moin produit_entier 
        cr√©er quadOP:87  str:__TEMP__9
operande-> $ ( EXPR somme_entiere )
concatenation-> operande 
    ;
instruction-> ID = concatenation
        cr√©er quadOP:88  str:somme
liste_instruction->instruction
        cr√©er quadOP:89  cst:0
    mot/id/entier:i
    =
    $
    (
    expr
    $
    {
    mot/id/entier:i
    }
operande_entier-> $ { id } 
        cr√©er quadOP:90  str:i
produit_entier-> operande_entier 
    +
somme_entiere-> produit_entier 
    mot/id/entier:1
operande_entier-> ENTIER 
ToInt: 1
        cr√©er quadOP:91  cst:1
produit_entier-> operande_entier 
    )
somme_entiere-> somme_entiere plus_ou_moin produit_entier 
        cr√©er quadOP:92  str:__TEMP__10
operande-> $ ( EXPR somme_entiere )
concatenation-> operande 
    done
instruction-> ID = concatenation
        cr√©er quadOP:93  str:i
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:94  cst:0
M->empty
instruction-> WHILE test_bloc DO liste_instructions DONE 
        cr√©er quadOP:95  cst:50
        cr√©er quadOP:96  cst:57
liste_instruction->instruction
        cr√©er quadOP:97  cst:0
    ;
    echo
    $
    (
    expr
    $
    {
    mot/id/entier:somme
    }
operande_entier-> $ { id } 
        cr√©er quadOP:98  str:somme
produit_entier-> operande_entier 
    /
    $
    mot/id/entier:1
operande_entier-> $ ENTIER 
ToInt: 1
        cr√©er quadOP:99  str:$1
produit_entier-> produit_entier fois_div_mod operande_entier
        cr√©er quadOP:100  str:__TEMP__11
    )
somme_entiere-> produit_entier 
operande-> $ ( EXPR somme_entiere )
liste_operandes-> operande 
        cr√©er quadOP:101  cst:1
        cr√©er quadOP:102  str:$
    }
instruction-> MYECHO liste_operandes 
        cr√©er quadOP:103  cst:1
        cr√©er quadOP:104  str:$
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:105  cst:0
declaration_de_fonction-> id ( ) { decl_loc liste_instructions }
        cr√©er quadOP:106  str:moyenne
instruction-> declaration_de_fonction 
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:107  cst:0
    ;
    echo
    chaine:"Nombre de valeurs : "
operande-> CHAINE:"Nombre de valeurs : "
        cr√©er quadOP:108  str:"Nombre de valeurs : "
liste_operandes-> operande 
        cr√©er quadOP:109  cst:1
        cr√©er quadOP:110  str:$
    ;
instruction-> MYECHO liste_operandes 
        cr√©er quadOP:111  cst:1
        cr√©er quadOP:112  str:$
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:113  cst:0
    read
    mot/id/entier:nombre
    ;
instruction-> READ ID 
        cr√©er quadOP:114  str:nombre
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:115  cst:0
    mot/id/entier:lecture_valeurs
    $
    {
    mot/id/entier:nombre
    }
operande-> $ { ID }
        cr√©er quadOP:116  str:nombre
liste_operandes-> operande 
        cr√©er quadOP:117  cst:1
        cr√©er quadOP:118  str:$
    ;
appel_de_fonction-> id liste_operandes 
        cr√©er quadOP:119  str:lecture_valeurs
instruction-> appel_de_fonction 
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:120  cst:0
    if
    test
    $
    ?
operande-> $ ?
        cr√©er quadOP:121  str:$?
    =
concatenation-> operande 
    mot/id/entier:0
operande-> MOT
        cr√©er quadOP:122  str:0
concatenation-> operande 
    then
test_instruction-> concatenation = concatenation 
        cr√©er quadOP:123  str:__TEMP__12
test_expr3 -> test_instruction 
test_expr2-> test_expr3 
2
3
test_expr-> test_expr2 
test_bloc-> TEST test_expr 
M->empty
    echo
    chaine:"Moyenne = "
operande-> CHAINE:"Moyenne = "
        cr√©er quadOP:124  str:"Moyenne = "
liste_operandes-> operande 
        cr√©er quadOP:125  cst:1
        cr√©er quadOP:126  str:$
    $
    (
    mot/id/entier:moyenne
    $
    {
    mot/id/entier:nombre
    }
operande-> $ { ID }
        cr√©er quadOP:127  str:nombre
liste_operandes-> operande 
        cr√©er quadOP:128  cst:1
        cr√©er quadOP:129  str:$
    )
appel_de_fonction-> id liste_operandes 
        cr√©er quadOP:130  str:moyenne
operande-> $ ( appel_de_fonction )
liste_operandes-> liste_operandes operande 
        cr√©er quadOP:131  cst:2
        cr√©er quadOP:132  str:$
    chaine:"\n"
operande-> CHAINE:"\n"
        cr√©er quadOP:133  str:"\n"
liste_operandes-> liste_operandes operande 
        cr√©er quadOP:134  cst:3
        cr√©er quadOP:135  str:$
    else
instruction-> MYECHO liste_operandes 
        cr√©er quadOP:136  cst:1
        cr√©er quadOP:137  str:$
        cr√©er quadOP:138  cst:2
        cr√©er quadOP:139  str:$
        cr√©er quadOP:140  cst:3
        cr√©er quadOP:141  str:$
liste_instruction->instruction
        cr√©er quadOP:142  cst:0
M->empty
    echo
    chaine:"Erreur\n"
operande-> CHAINE:"Erreur\n"
        cr√©er quadOP:143  str:"Erreur\n"
liste_operandes-> operande 
        cr√©er quadOP:144  cst:1
        cr√©er quadOP:145  str:$
    fi
instruction-> MYECHO liste_operandes 
        cr√©er quadOP:146  cst:1
        cr√©er quadOP:147  str:$
liste_instruction->instruction
        cr√©er quadOP:148  cst:0
else_part->ELSE liste_instructions
instruction-> IF test_bloc THEN liste_instructions else_part FI 
        cr√©er quadOP:149  cst:74
        cr√©er quadOP:150  cst:83
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:151  cst:0
    ;
    exit
instruction->EXIT
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:152  cst:0
programme->liste_instruction

Affichage Lglobal:
ligne 1:  res: tab:valeurs  TAB[]CREAT  op1: cst:4  op2: NULL 
ligne 2:  res: addr:3  GOTO  op1: NULL  op2: NULL 
ligne 3:  res: fct:lecture_valeurs  FCT:  op1: NULL  op2: NULL 
ligne 4:  res: id:i  EQUAL  op1: string:0  op2: NULL 
ligne 5:  res: id:nombre  EQUAL  op1: id:$1  op2: NULL 
ligne 6:  res: tab:$  TAB[]EQUAL  op1: cst:1  op2: string:"Il faut saisir " 
ligne 7:  res: tab:$  TAB[]EQUAL  op1: cst:2  op2: id:$1 
ligne 8:  res: tab:$  TAB[]EQUAL  op1: cst:3  op2: string:"valeurs entieres\n" 
ligne 9:  res: tab:$  ECHO  op1: cst:1  op2: NULL 
ligne 10:  res: tab:$  ECHO  op1: cst:2  op2: NULL 
ligne 11:  res: tab:$  ECHO  op1: cst:3  op2: NULL 
ligne 12:  res: addr:13  GOTO  op1: NULL  op2: NULL 
ligne 13:  res: id:__TEMP__1  IF <  op1: id:i  op2: id:nombre 
ligne 14:  res: addr:16  IF _ GOTO  op1: id:__TEMP__1  op2: NULL 
ligne 15:  res: addr:40  GOTO  op1: NULL  op2: NULL 
ligne 16:  res: tab:$  TAB[]EQUAL  op1: cst:1  op2: string:"Entrez la valeur " 
ligne 17:  res: id:__TEMP__2  ADD  op1: id:i  op2: cst:1 
ligne 18:  res: tab:$  TAB[]EQUAL  op1: cst:2  op2: id:__TEMP__2 
ligne 19:  res: tab:$  TAB[]EQUAL  op1: cst:3  op2: string:" : \n" 
ligne 20:  res: tab:$  ECHO  op1: cst:1  op2: NULL 
ligne 21:  res: tab:$  ECHO  op1: cst:2  op2: NULL 
ligne 22:  res: tab:$  ECHO  op1: cst:3  op2: NULL 
ligne 23:  res: addr:24  GOTO  op1: NULL  op2: NULL 
ligne 24:  res: tab:valeurs  READ  op1: id:i  op2: NULL 
ligne 25:  res: addr:26  GOTO  op1: NULL  op2: NULL 
ligne 26:  res: id:__TEMP__3  TAB[]GIVE  op1: tab:valeurs  op2: id:i 
ligne 27:  res: id:__TEMP__4  IF >  op1: id:__TEMP__3  op2: string:0 
ligne 28:  res: id:__TEMP__5  NOT  op1: id:__TEMP__4  op2: NULL 
ligne 29:  res: addr:31  IF _ GOTO  op1: id:__TEMP__5  op2: NULL 
ligne 30:  res: addr:36  GOTO  op1: NULL  op2: NULL 
ligne 31:  res: tab:$  TAB[]EQUAL  op1: cst:1  op2: string:"Les valeurs doivent etre strictement positives !\n" 
ligne 32:  res: tab:$  ECHO  op1: cst:1  op2: NULL 
ligne 33:  res: addr:34  GOTO  op1: NULL  op2: NULL 
ligne 34:  res: cst:1  RETURN  op1: NULL  op2: NULL 
ligne 35:  res: addr:36  GOTO  op1: NULL  op2: NULL 
ligne 36:  res: addr:37  GOTO  op1: NULL  op2: NULL 
ligne 37:  res: id:__TEMP__6  ADD  op1: id:i  op2: cst:1 
ligne 38:  res: id:i  EQUAL  op1: id:__TEMP__6  op2: NULL 
ligne 39:  res: addr:13  GOTO  op1: NULL  op2: NULL 
ligne 40:  res: addr:41  GOTO  op1: NULL  op2: NULL 
ligne 41:  res: cst:0  RETURN  op1: NULL  op2: NULL 
ligne 42:  res: addr:43  GOTO  op1: NULL  op2: NULL 
ligne 43:  res: addr:44  GOTO  op1: NULL  op2: NULL 
ligne 44:  res: fct:moyenne  FCT:  op1: NULL  op2: NULL 
ligne 45:  res: id:i  EQUAL  op1: string:0  op2: NULL 
ligne 46:  res: id:somme  EQUAL  op1: string:0  op2: NULL 
ligne 47:  res: id:__TEMP__7  IF <  op1: id:i  op2: id:$1 
ligne 48:  res: addr:50  IF _ GOTO  op1: id:__TEMP__7  op2: NULL 
ligne 49:  res: addr:57  GOTO  op1: NULL  op2: NULL 
ligne 50:  res: id:__TEMP__8  TAB[]GIVE  op1: tab:valeurs  op2: id:i 
ligne 51:  res: id:__TEMP__9  ADD  op1: id:somme  op2: id:__TEMP__8 
ligne 52:  res: id:somme  EQUAL  op1: id:__TEMP__9  op2: NULL 
ligne 53:  res: addr:54  GOTO  op1: NULL  op2: NULL 
ligne 54:  res: id:__TEMP__10  ADD  op1: id:i  op2: cst:1 
ligne 55:  res: id:i  EQUAL  op1: id:__TEMP__10  op2: NULL 
ligne 56:  res: addr:47  GOTO  op1: NULL  op2: NULL 
ligne 57:  res: addr:58  GOTO  op1: NULL  op2: NULL 
ligne 58:  res: id:__TEMP__11  DIV  op1: id:somme  op2: id:$1 
ligne 59:  res: tab:$  TAB[]EQUAL  op1: cst:1  op2: id:__TEMP__11 
ligne 60:  res: tab:$  ECHO  op1: cst:1  op2: NULL 
ligne 61:  res: addr:62  GOTO  op1: NULL  op2: NULL 
ligne 62:  res: addr:63  GOTO  op1: NULL  op2: NULL 
ligne 63:  res: tab:$  TAB[]EQUAL  op1: cst:1  op2: string:"Nombre de valeurs : " 
ligne 64:  res: tab:$  ECHO  op1: cst:1  op2: NULL 
ligne 65:  res: addr:66  GOTO  op1: NULL  op2: NULL 
ligne 66:  res: id:nombre  READ  op1: NULL  op2: NULL 
ligne 67:  res: addr:68  GOTO  op1: NULL  op2: NULL 
ligne 68:  res: tab:$  TAB[]EQUAL  op1: cst:1  op2: id:nombre 
ligne 69:  res: fct:lecture_valeurs  CALL FCT ()  op1: NULL  op2: NULL 
ligne 70:  res: addr:71  GOTO  op1: NULL  op2: NULL 
ligne 71:  res: id:__TEMP__12  IF ==  op1: id:$?  op2: string:0 
ligne 72:  res: addr:74  IF _ GOTO  op1: id:__TEMP__12  op2: NULL 
ligne 73:  res: addr:83  GOTO  op1: NULL  op2: NULL 
ligne 74:  res: tab:$  TAB[]EQUAL  op1: cst:1  op2: string:"Moyenne = " 
ligne 75:  res: tab:$  TAB[]EQUAL  op1: cst:1  op2: id:nombre 
ligne 76:  res: fct:moyenne  CALL FCT ()  op1: NULL  op2: NULL 
ligne 77:  res: tab:$  TAB[]EQUAL  op1: cst:2  op2: cst:1 
ligne 78:  res: tab:$  TAB[]EQUAL  op1: cst:3  op2: string:"\n" 
ligne 79:  res: tab:$  ECHO  op1: cst:1  op2: NULL 
ligne 80:  res: tab:$  ECHO  op1: cst:2  op2: NULL 
ligne 81:  res: tab:$  ECHO  op1: cst:3  op2: NULL 
ligne 82:  res: addr:83  GOTO  op1: NULL  op2: NULL 
ligne 83:  res: tab:$  TAB[]EQUAL  op1: cst:1  op2: string:"Erreur\n" 
ligne 84:  res: tab:$  ECHO  op1: cst:1  op2: NULL 
ligne 85:  res: addr:86  GOTO  op1: NULL  op2: NULL 
ligne 86:  res: addr:87  GOTO  op1: NULL  op2: NULL 
ligne 87:  res: NULL  EXIT  op1: NULL  op2: NULL 
ligne 88:  res: addr:89  GOTO  op1: NULL  op2: NULL 
Yacc return : ->0

### MIPS: ###

 TAB[]CREAT 
 GOTO 
 FCT: 
 EQUAL 
 EQUAL 
 TAB[]EQUAL 
 TAB[]EQUAL 
 TAB[]EQUAL 
 ECHO 
 ECHO 
 ECHO 
 GOTO 
 IF < 
 IF _ GOTO 
 GOTO 
 TAB[]EQUAL 
 ADD 
 TAB[]EQUAL 
 TAB[]EQUAL 
 ECHO 
 ECHO 
 ECHO 
 GOTO 
 READ 
 GOTO 
 TAB[]GIVE 
 IF > 
 NOT 
 IF _ GOTO 
 GOTO 
 TAB[]EQUAL 
 ECHO 
 GOTO 
 RETURN 
 GOTO 
 GOTO 
 ADD 
 EQUAL 
 GOTO 
 GOTO 
 RETURN 
 GOTO 
 GOTO 
 FCT: 
 EQUAL 
 EQUAL 
 IF < 
 IF _ GOTO 
 GOTO 
 TAB[]GIVE 
 ADD 
 EQUAL 
 GOTO 
 ADD 
 EQUAL 
 GOTO 
 GOTO 
 DIV 
 TAB[]EQUAL 
 ECHO 
 GOTO 
 GOTO 
 TAB[]EQUAL 
 ECHO 
 GOTO 
 READ 
 GOTO 
 TAB[]EQUAL 
 CALL FCT () 
 GOTO 
 IF == 
 IF _ GOTO 
 GOTO 
 TAB[]EQUAL 
 TAB[]EQUAL 
 CALL FCT () 
 TAB[]EQUAL 
 TAB[]EQUAL 
 ECHO 
 ECHO 
 ECHO 
 GOTO 
 TAB[]EQUAL 
 ECHO 
 GOTO 
 GOTO 
 EXIT 
 GOTO 

### Table of symbols : ###

n¬∞23346 : ID			Type : int      	somme (local variable)
n¬∞29818 : ID			Type : int      	i (local variable)
n¬∞31078 : ID			Type : undefined	lecture_valeurs
n¬∞72564 : ID			Type : undefined	nombre
n¬∞72564 : ID			Type : undefined	nombre (local variable)
n¬∞92364 : ID			Type : undefined	moyenne
n¬∞97491 : Array of 4 elements				valeurs
n¬∞97491 : ID			Type : undefined	valeurs (local variable)

Free Lglobal:


[92m-------------------------------------------------TEST-------------------------------------------------[0m tests/test5_echo_mips.txt
    declare
    mot/id/entier:abc
    [
    mot/id/entier:5
    ]
instruction-> DECLARE ID [ ENTIER ] 
ToInt: 5
        cr√©er quadOP:0  str:abc
        cr√©er quadOP:1  cst:5
liste_instruction->instruction
        cr√©er quadOP:2  cst:0
    ;
    exit
instruction->EXIT
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:3  cst:0
programme->liste_instruction

Affichage Lglobal:
ligne 1:  res: tab:abc  TAB[]CREAT  op1: cst:5  op2: NULL 
ligne 2:  res: addr:3  GOTO  op1: NULL  op2: NULL 
ligne 3:  res: NULL  EXIT  op1: NULL  op2: NULL 
ligne 4:  res: addr:5  GOTO  op1: NULL  op2: NULL 
Yacc return : ->0

### MIPS: ###

 TAB[]CREAT 
 GOTO 
 EXIT 
 GOTO 

### Table of symbols : ###

n¬∞66423 : Array of 5 elements				abc

Free Lglobal:


[92m-------------------------------------------------TEST-------------------------------------------------[0m tests/test3_MIPS.txt
    mot/id/entier:i
    =
    mot/id/entier:8
operande-> MOT
        cr√©er quadOP:0  str:8
concatenation-> operande 
    ;
instruction-> ID = concatenation
        cr√©er quadOP:1  str:i
liste_instruction->instruction
        cr√©er quadOP:2  cst:0
    mot/id/entier:c
    =
    mot/id/entier:4
operande-> MOT
        cr√©er quadOP:3  str:4
concatenation-> operande 
    ;
instruction-> ID = concatenation
        cr√©er quadOP:4  str:c
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:5  cst:0
    mot/id/entier:k
    =
    $
    (
    expr
    $
    {
    mot/id/entier:i
    }
operande_entier-> $ { id } 
        cr√©er quadOP:6  str:i
produit_entier-> operande_entier 
    +
somme_entiere-> produit_entier 
    $
    {
    mot/id/entier:c
    }
operande_entier-> $ { id } 
        cr√©er quadOP:7  str:c
produit_entier-> operande_entier 
    )
somme_entiere-> somme_entiere plus_ou_moin produit_entier 
        cr√©er quadOP:8  str:__TEMP__1
operande-> $ ( EXPR somme_entiere )
concatenation-> operande 
    ;
instruction-> ID = concatenation
        cr√©er quadOP:9  str:k
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:10  cst:0
    mot/id/entier:v
    =
    $
    (
    expr
    $
    {
    mot/id/entier:k
    }
operande_entier-> $ { id } 
        cr√©er quadOP:11  str:k
produit_entier-> operande_entier 
    +
somme_entiere-> produit_entier 
    $
    {
    mot/id/entier:k
    }
operande_entier-> $ { id } 
        cr√©er quadOP:12  str:k
produit_entier-> operande_entier 
    )
somme_entiere-> somme_entiere plus_ou_moin produit_entier 
        cr√©er quadOP:13  str:__TEMP__2
operande-> $ ( EXPR somme_entiere )
concatenation-> operande 
    ;
instruction-> ID = concatenation
        cr√©er quadOP:14  str:v
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:15  cst:0
    mot/id/entier:p
    =
    $
    (
    expr
    $
    {
    mot/id/entier:v
    }
operande_entier-> $ { id } 
        cr√©er quadOP:16  str:v
produit_entier-> operande_entier 
    +
somme_entiere-> produit_entier 
    $
    {
    mot/id/entier:i
    }
operande_entier-> $ { id } 
        cr√©er quadOP:17  str:i
produit_entier-> operande_entier 
    )
somme_entiere-> somme_entiere plus_ou_moin produit_entier 
        cr√©er quadOP:18  str:__TEMP__3
operande-> $ ( EXPR somme_entiere )
concatenation-> operande 
    ;
instruction-> ID = concatenation
        cr√©er quadOP:19  str:p
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:20  cst:0
    exit
instruction->EXIT
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:21  cst:0
programme->liste_instruction

Affichage Lglobal:
ligne 1:  res: id:i  EQUAL  op1: string:8  op2: NULL 
ligne 2:  res: addr:3  GOTO  op1: NULL  op2: NULL 
ligne 3:  res: id:c  EQUAL  op1: string:4  op2: NULL 
ligne 4:  res: addr:5  GOTO  op1: NULL  op2: NULL 
ligne 5:  res: id:__TEMP__1  ADD  op1: id:i  op2: id:c 
ligne 6:  res: id:k  EQUAL  op1: id:__TEMP__1  op2: NULL 
ligne 7:  res: addr:8  GOTO  op1: NULL  op2: NULL 
ligne 8:  res: id:__TEMP__2  ADD  op1: id:k  op2: id:k 
ligne 9:  res: id:v  EQUAL  op1: id:__TEMP__2  op2: NULL 
ligne 10:  res: addr:11  GOTO  op1: NULL  op2: NULL 
ligne 11:  res: id:__TEMP__3  ADD  op1: id:v  op2: id:i 
ligne 12:  res: id:p  EQUAL  op1: id:__TEMP__3  op2: NULL 
ligne 13:  res: addr:14  GOTO  op1: NULL  op2: NULL 
ligne 14:  res: NULL  EXIT  op1: NULL  op2: NULL 
ligne 15:  res: addr:16  GOTO  op1: NULL  op2: NULL 
Yacc return : ->0

### MIPS: ###

 EQUAL 
 GOTO 
 EQUAL 
 GOTO 
 ADD 
 EQUAL 
 GOTO 
 ADD 
 EQUAL 
 GOTO 
 ADD 
 EQUAL 
 GOTO 
 EXIT 
 GOTO 

### Table of symbols : ###

n¬∞29812 : ID			Type : int      	c
n¬∞29818 : ID			Type : int      	i
n¬∞29820 : ID			Type : int      	k
n¬∞29825 : ID			Type : int      	p
n¬∞29831 : ID			Type : int      	v

Free Lglobal:


[92m-------------------------------------------------TEST-------------------------------------------------[0m tests/test1.txt
    commentaire
    declare
    mot/id/entier:mots
    [
    mot/id/entier:100
    ]
instruction-> DECLARE ID [ ENTIER ] 
ToInt: 100
        cr√©er quadOP:0  str:mots
        cr√©er quadOP:1  cst:100
liste_instruction->instruction
        cr√©er quadOP:2  cst:0
    ;
    echo
    chaine:"Entrez le nombre de mots de la phrase : "
operande-> CHAINE:"Entrez le nombre de mots de la phrase : "
        cr√©er quadOP:3  str:"Entrez le nombre de mots de la phrase : "
liste_operandes-> operande 
        cr√©er quadOP:4  cst:1
        cr√©er quadOP:5  str:$
    ;
instruction-> MYECHO liste_operandes 
        cr√©er quadOP:6  cst:1
        cr√©er quadOP:7  str:$
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:8  cst:0
    read
    mot/id/entier:nombre
    ;
instruction-> READ ID 
        cr√©er quadOP:9  str:nombre
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:10  cst:0
    mot/id/entier:i
    =
    mot/id/entier:1
operande-> MOT
        cr√©er quadOP:11  str:1
concatenation-> operande 
    ;
instruction-> ID = concatenation
        cr√©er quadOP:12  str:i
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:13  cst:0
    while
M->empty
    test
    $
    {
    mot/id/entier:i
    }
operande-> $ { ID }
        cr√©er quadOP:14  str:i
    -le
operateur2-> -le
    $
    {
    mot/id/entier:nombre
    }
operande-> $ { ID }
        cr√©er quadOP:15  str:nombre
test_instruction-> operande operateur2 operande 
        cr√©er quadOP:16  str:__TEMP__1
test_expr3 -> test_instruction 
test_expr2-> test_expr3 
2
3
    do
test_expr-> test_expr2 
test_bloc-> TEST test_expr 
M->empty
    echo
    chaine:"Entrez le mot numero "
operande-> CHAINE:"Entrez le mot numero "
        cr√©er quadOP:17  str:"Entrez le mot numero "
liste_operandes-> operande 
        cr√©er quadOP:18  cst:1
        cr√©er quadOP:19  str:$
    $
    {
    mot/id/entier:i
    }
operande-> $ { ID }
        cr√©er quadOP:20  str:i
liste_operandes-> liste_operandes operande 
        cr√©er quadOP:21  cst:2
        cr√©er quadOP:22  str:$
    chaine:" : "
operande-> CHAINE:" : "
        cr√©er quadOP:23  str:" : "
liste_operandes-> liste_operandes operande 
        cr√©er quadOP:24  cst:3
        cr√©er quadOP:25  str:$
    ;
instruction-> MYECHO liste_operandes 
        cr√©er quadOP:26  cst:1
        cr√©er quadOP:27  str:$
        cr√©er quadOP:28  cst:2
        cr√©er quadOP:29  str:$
        cr√©er quadOP:30  cst:3
        cr√©er quadOP:31  str:$
liste_instruction->instruction
        cr√©er quadOP:32  cst:0
    read
    mot/id/entier:mots
    [
    $
    {
    mot/id/entier:i
    }
operande_entier-> $ { id } 
        cr√©er quadOP:33  str:i
    ]
instruction-> READ ID [ operande_entier ] 
        cr√©er quadOP:34  str:mots
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:35  cst:0
    ;
    mot/id/entier:i
    =
    $
    (
    expr
    $
    {
    mot/id/entier:i
    }
operande_entier-> $ { id } 
        cr√©er quadOP:36  str:i
produit_entier-> operande_entier 
    +
somme_entiere-> produit_entier 
    mot/id/entier:1
operande_entier-> ENTIER 
ToInt: 1
        cr√©er quadOP:37  cst:1
produit_entier-> operande_entier 
    )
somme_entiere-> somme_entiere plus_ou_moin produit_entier 
        cr√©er quadOP:38  str:__TEMP__2
operande-> $ ( EXPR somme_entiere )
concatenation-> operande 
    done
instruction-> ID = concatenation
        cr√©er quadOP:39  str:i
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:40  cst:0
M->empty
instruction-> WHILE test_bloc DO liste_instructions DONE 
        cr√©er quadOP:41  cst:13
        cr√©er quadOP:42  cst:25
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:43  cst:0
    ;
    mot/id/entier:new_phrase
    =
    chaine:""
operande-> CHAINE:""
        cr√©er quadOP:44  str:""
concatenation-> operande 
    ;
instruction-> ID = concatenation
        cr√©er quadOP:45  str:new_phrase
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:46  cst:0
    echo
    $
    {
    mot/id/entier:mots
    [
    *
    ]
    }
liste_operandes-> $ { ID [ * ] } 
        cr√©er quadOP:47  str:__TEMP__3
        cr√©er quadOP:48  str:$
        cr√©er quadOP:49  str:mots
        cr√©er quadOP:50  cst:0
    ;
instruction-> MYECHO liste_operandes 
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:51  cst:0
    commentaire
    for
    mot/id/entier:mot
    in
    $
    {
    mot/id/entier:mots
    [
    *
    ]
    }
liste_operandes-> $ { ID [ * ] } 
        cr√©er quadOP:52  str:__TEMP__4
        cr√©er quadOP:53  str:$
        cr√©er quadOP:54  str:mots
        cr√©er quadOP:55  cst:0
    do
        cr√©er quadOP:56  str:__TEMP__5
        cr√©er quadOP:57  cst:0
        cr√©er quadOP:58  cst:1
        cr√©er quadOP:59  str:__TEMP__6
        cr√©er quadOP:60  str:$
    case
    $
    {
    mot/id/entier:mot
    }
operande-> $ { ID }
        cr√©er quadOP:61  str:mot
    in
    mot/id/entier:Anne
filtre->MOT
        cr√©er quadOP:62  str:Anne
        cr√©er quadOP:63  str:__TEMP__7
    |
M->empty
    mot/id/entier:Corinne
filtre->filtre | MOT
        cr√©er quadOP:64  cst:41
        cr√©er quadOP:65  str:Corinne
        cr√©er quadOP:66  str:__TEMP__8
    |
M->empty
    mot/id/entier:Sabine
filtre->filtre | MOT
        cr√©er quadOP:67  cst:44
        cr√©er quadOP:68  str:Sabine
        cr√©er quadOP:69  str:__TEMP__9
    |
M->empty
    mot/id/entier:Emilie
filtre->filtre | MOT
        cr√©er quadOP:70  cst:47
        cr√©er quadOP:71  str:Emilie
        cr√©er quadOP:72  str:__TEMP__10
    )
M->empty
    mot/id/entier:new_phrase
    =
    $
    {
    mot/id/entier:new_phrase
    }
operande-> $ { ID }
        cr√©er quadOP:73  str:new_phrase
concatenation-> operande 
    chaine:" "
operande-> CHAINE:" "
        cr√©er quadOP:74  str:" "
concatenation-> concatenation operande 
        cr√©er quadOP:75  str:__TEMP__11
    mot/id/entier:elle
operande-> MOT
        cr√©er quadOP:76  str:elle
concatenation-> concatenation operande 
        cr√©er quadOP:77  str:__TEMP__12
    ;
instruction-> ID = concatenation
        cr√©er quadOP:78  str:new_phrase
liste_instruction->instruction
        cr√©er quadOP:79  cst:0
    ;
liste_cas->filtre ) liste_instructions ; ; 
        cr√©er quadOP:80  cst:50
        cr√©er quadOP:81  cst:50
        cr√©er quadOP:82  cst:50
        cr√©er quadOP:83  cst:50
        cr√©er quadOP:84  cst:54
    mot/id/entier:Pierre
filtre->MOT
        cr√©er quadOP:85  str:Pierre
        cr√©er quadOP:86  str:__TEMP__13
    |
M->empty
    mot/id/entier:Paul
filtre->filtre | MOT
        cr√©er quadOP:87  cst:57
        cr√©er quadOP:88  str:Paul
        cr√©er quadOP:89  str:__TEMP__14
    |
M->empty
    mot/id/entier:Jacques
filtre->filtre | MOT
        cr√©er quadOP:90  cst:60
        cr√©er quadOP:91  str:Jacques
        cr√©er quadOP:92  str:__TEMP__15
    |
M->empty
    mot/id/entier:Albert
filtre->filtre | MOT
        cr√©er quadOP:93  cst:63
        cr√©er quadOP:94  str:Albert
        cr√©er quadOP:95  str:__TEMP__16
    )
M->empty
    mot/id/entier:new_phrase
    =
    $
    {
    mot/id/entier:new_phrase
    }
operande-> $ { ID }
        cr√©er quadOP:96  str:new_phrase
concatenation-> operande 
    chaine:" "
operande-> CHAINE:" "
        cr√©er quadOP:97  str:" "
concatenation-> concatenation operande 
        cr√©er quadOP:98  str:__TEMP__17
    mot/id/entier:lui
operande-> MOT
        cr√©er quadOP:99  str:lui
concatenation-> concatenation operande 
        cr√©er quadOP:100  str:__TEMP__18
    ;
instruction-> ID = concatenation
        cr√©er quadOP:101  str:new_phrase
liste_instruction->instruction
        cr√©er quadOP:102  cst:0
    ;
liste_cas->liste_cas filtre ) liste_instructions ; ; 
        cr√©er quadOP:103  cst:66
        cr√©er quadOP:104  cst:66
        cr√©er quadOP:105  cst:66
        cr√©er quadOP:106  cst:66
        cr√©er quadOP:107  cst:70
    *
filtre-> *
    )
M->empty
    mot/id/entier:new_phrase
    =
    $
    {
    mot/id/entier:new_phrase
    }
operande-> $ { ID }
        cr√©er quadOP:108  str:new_phrase
concatenation-> operande 
    chaine:" "
operande-> CHAINE:" "
        cr√©er quadOP:109  str:" "
concatenation-> concatenation operande 
        cr√©er quadOP:110  str:__TEMP__19
    $
    {
    mot/id/entier:mot
    }
operande-> $ { ID }
        cr√©er quadOP:111  str:mot
concatenation-> concatenation operande 
        cr√©er quadOP:112  str:__TEMP__20
    ;
instruction-> ID = concatenation
        cr√©er quadOP:113  str:new_phrase
liste_instruction->instruction
        cr√©er quadOP:114  cst:0
    ;
liste_cas->liste_cas filtre ) liste_instructions ; ; 
    esac
instruction-> CASE operande IN liste_cas ESAC 
liste_instruction->instruction
        cr√©er quadOP:115  cst:0
    done
instruction-> FOR ID IN liste_operandes DO liste_instructions DONE  
        cr√©er quadOP:116  cst:0
        cr√©er quadOP:117  cst:75
        cr√©er quadOP:118  str:mot
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:119  cst:0
    ;
    echo
    chaine:"Nouvelle phrase : "
operande-> CHAINE:"Nouvelle phrase : "
        cr√©er quadOP:120  str:"Nouvelle phrase : "
liste_operandes-> operande 
        cr√©er quadOP:121  cst:1
        cr√©er quadOP:122  str:$
    $
    {
    mot/id/entier:new_phrase
    }
operande-> $ { ID }
        cr√©er quadOP:123  str:new_phrase
liste_operandes-> liste_operandes operande 
        cr√©er quadOP:124  cst:2
        cr√©er quadOP:125  str:$
    ;
instruction-> MYECHO liste_operandes 
        cr√©er quadOP:126  cst:1
        cr√©er quadOP:127  str:$
        cr√©er quadOP:128  cst:2
        cr√©er quadOP:129  str:$
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:130  cst:0
    commentaire
    exit
instruction->EXIT
liste_instruction->liste_instructions ; instruction
        cr√©er quadOP:131  cst:0
programme->liste_instruction

Affichage Lglobal:
ligne 1:  res: tab:mots  TAB[]CREAT  op1: cst:100  op2: NULL 
ligne 2:  res: addr:3  GOTO  op1: NULL  op2: NULL 
ligne 3:  res: tab:$  TAB[]EQUAL  op1: cst:1  op2: string:"Entrez le nombre de mots de la phrase : " 
ligne 4:  res: tab:$  ECHO  op1: cst:1  op2: NULL 
ligne 5:  res: addr:6  GOTO  op1: NULL  op2: NULL 
ligne 6:  res: id:nombre  READ  op1: NULL  op2: NULL 
ligne 7:  res: addr:8  GOTO  op1: NULL  op2: NULL 
ligne 8:  res: id:i  EQUAL  op1: string:1  op2: NULL 
ligne 9:  res: addr:10  GOTO  op1: NULL  op2: NULL 
ligne 10:  res: id:__TEMP__1  IF <=  op1: id:i  op2: id:nombre 
ligne 11:  res: addr:13  IF _ GOTO  op1: id:__TEMP__1  op2: NULL 
ligne 12:  res: addr:25  GOTO  op1: NULL  op2: NULL 
ligne 13:  res: tab:$  TAB[]EQUAL  op1: cst:1  op2: string:"Entrez le mot numero " 
ligne 14:  res: tab:$  TAB[]EQUAL  op1: cst:2  op2: id:i 
ligne 15:  res: tab:$  TAB[]EQUAL  op1: cst:3  op2: string:" : " 
ligne 16:  res: tab:$  ECHO  op1: cst:1  op2: NULL 
ligne 17:  res: tab:$  ECHO  op1: cst:2  op2: NULL 
ligne 18:  res: tab:$  ECHO  op1: cst:3  op2: NULL 
ligne 19:  res: addr:20  GOTO  op1: NULL  op2: NULL 
ligne 20:  res: tab:mots  READ  op1: id:i  op2: NULL 
ligne 21:  res: addr:22  GOTO  op1: NULL  op2: NULL 
ligne 22:  res: id:__TEMP__2  ADD  op1: id:i  op2: cst:1 
ligne 23:  res: id:i  EQUAL  op1: id:__TEMP__2  op2: NULL 
ligne 24:  res: addr:10  GOTO  op1: NULL  op2: NULL 
ligne 25:  res: addr:26  GOTO  op1: NULL  op2: NULL 
ligne 26:  res: id:new_phrase  EQUAL  op1: string:""  op2: NULL 
ligne 27:  res: addr:28  GOTO  op1: NULL  op2: NULL 
ligne 28:  res: id:__TEMP__3  TAB[]GIVE  op1: tab:mots  op2: cst:0 
ligne 29:  res: tab:$  TAB[]EQUAL  op1: cst:0  op2: id:__TEMP__3 
ligne 30:  res: addr:31  GOTO  op1: NULL  op2: NULL 
ligne 31:  res: id:__TEMP__4  TAB[]GIVE  op1: tab:mots  op2: cst:0 
ligne 32:  res: tab:$  TAB[]EQUAL  op1: cst:0  op2: id:__TEMP__4 
ligne 33:  res: id:__TEMP__5  EQUAL  op1: cst:0  op2: NULL 
ligne 34:  res: id:__TEMP__5  ADD  op1: id:__TEMP__5  op2: cst:1 
ligne 35:  res: id:__TEMP__6  IF >  op1: id:__TEMP__5  op2: cst:0 
ligne 36:  res: addr:75  IF _ GOTO  op1: id:__TEMP__6  op2: NULL 
ligne 37:  res: id:mot  TAB[]GIVE  op1: tab:$  op2: id:__TEMP__5 
ligne 38:  res: id:__TEMP__7  IF ==  op1: id:mot  op2: string:Anne 
ligne 39:  res: addr:50  IF _ GOTO  op1: id:__TEMP__7  op2: NULL 
ligne 40:  res: addr:41  GOTO  op1: NULL  op2: NULL 
ligne 41:  res: id:__TEMP__8  IF ==  op1: id:mot  op2: string:Corinne 
ligne 42:  res: addr:50  IF _ GOTO  op1: id:__TEMP__8  op2: NULL 
ligne 43:  res: addr:44  GOTO  op1: NULL  op2: NULL 
ligne 44:  res: id:__TEMP__9  IF ==  op1: id:mot  op2: string:Sabine 
ligne 45:  res: addr:50  IF _ GOTO  op1: id:__TEMP__9  op2: NULL 
ligne 46:  res: addr:47  GOTO  op1: NULL  op2: NULL 
ligne 47:  res: id:__TEMP__10  IF ==  op1: id:mot  op2: string:Emilie 
ligne 48:  res: addr:50  IF _ GOTO  op1: id:__TEMP__10  op2: NULL 
ligne 49:  res: addr:54  GOTO  op1: NULL  op2: NULL 
ligne 50:  res: id:__TEMP__11  CONCAT OPERANDE  op1: id:new_phrase  op2: string:" " 
ligne 51:  res: id:__TEMP__12  CONCAT OPERANDE  op1: id:__TEMP__11  op2: string:elle 
ligne 52:  res: id:new_phrase  EQUAL  op1: id:__TEMP__12  op2: NULL 
ligne 53:  res: addr:54  GOTO  op1: NULL  op2: NULL 
ligne 54:  res: id:__TEMP__13  IF ==  op1: id:mot  op2: string:Pierre 
ligne 55:  res: addr:66  IF _ GOTO  op1: id:__TEMP__13  op2: NULL 
ligne 56:  res: addr:57  GOTO  op1: NULL  op2: NULL 
ligne 57:  res: id:__TEMP__14  IF ==  op1: id:mot  op2: string:Paul 
ligne 58:  res: addr:66  IF _ GOTO  op1: id:__TEMP__14  op2: NULL 
ligne 59:  res: addr:60  GOTO  op1: NULL  op2: NULL 
ligne 60:  res: id:__TEMP__15  IF ==  op1: id:mot  op2: string:Jacques 
ligne 61:  res: addr:66  IF _ GOTO  op1: id:__TEMP__15  op2: NULL 
ligne 62:  res: addr:63  GOTO  op1: NULL  op2: NULL 
ligne 63:  res: id:__TEMP__16  IF ==  op1: id:mot  op2: string:Albert 
ligne 64:  res: addr:66  IF _ GOTO  op1: id:__TEMP__16  op2: NULL 
ligne 65:  res: addr:70  GOTO  op1: NULL  op2: NULL 
ligne 66:  res: id:__TEMP__17  CONCAT OPERANDE  op1: id:new_phrase  op2: string:" " 
ligne 67:  res: id:__TEMP__18  CONCAT OPERANDE  op1: id:__TEMP__17  op2: string:lui 
ligne 68:  res: id:new_phrase  EQUAL  op1: id:__TEMP__18  op2: NULL 
ligne 69:  res: addr:70  GOTO  op1: NULL  op2: NULL 
ligne 70:  res: id:__TEMP__19  CONCAT OPERANDE  op1: id:new_phrase  op2: string:" " 
ligne 71:  res: id:__TEMP__20  CONCAT OPERANDE  op1: id:__TEMP__19  op2: id:mot 
ligne 72:  res: id:new_phrase  EQUAL  op1: id:__TEMP__20  op2: NULL 
ligne 73:  res: addr:74  GOTO  op1: NULL  op2: NULL 
ligne 74:  res: addr:34  GOTO  op1: NULL  op2: NULL 
ligne 75:  res: addr:76  GOTO  op1: NULL  op2: NULL 
ligne 76:  res: tab:$  TAB[]EQUAL  op1: cst:1  op2: string:"Nouvelle phrase : " 
ligne 77:  res: tab:$  TAB[]EQUAL  op1: cst:2  op2: id:new_phrase 
ligne 78:  res: tab:$  ECHO  op1: cst:1  op2: NULL 
ligne 79:  res: tab:$  ECHO  op1: cst:2  op2: NULL 
ligne 80:  res: addr:81  GOTO  op1: NULL  op2: NULL 
ligne 81:  res: NULL  EXIT  op1: NULL  op2: NULL 
ligne 82:  res: addr:83  GOTO  op1: NULL  op2: NULL 
Yacc return : ->0

### MIPS: ###

 TAB[]CREAT 
 GOTO 
 TAB[]EQUAL 
 ECHO 
 GOTO 
 READ 
 GOTO 
 EQUAL 
 GOTO 
 IF <= 
 IF _ GOTO 
 GOTO 
 TAB[]EQUAL 
 TAB[]EQUAL 
 TAB[]EQUAL 
 ECHO 
 ECHO 
 ECHO 
 GOTO 
 READ 
 GOTO 
 ADD 
 EQUAL 
 GOTO 
 GOTO 
 EQUAL 
 GOTO 
 TAB[]GIVE 
 TAB[]EQUAL 
 GOTO 
 TAB[]GIVE 
 TAB[]EQUAL 
 EQUAL 
 ADD 
 IF > 
 IF _ GOTO 
 TAB[]GIVE 
 IF == 
 IF _ GOTO 
 GOTO 
 IF == 
 IF _ GOTO 
 GOTO 
 IF == 
 IF _ GOTO 
 GOTO 
 IF == 
 IF _ GOTO 
 GOTO 
 CONCAT OPERANDE 
 CONCAT OPERANDE 
 EQUAL 
 GOTO 
 IF == 
 IF _ GOTO 
 GOTO 
 IF == 
 IF _ GOTO 
 GOTO 
 IF == 
 IF _ GOTO 
 GOTO 
 IF == 
 IF _ GOTO 
 GOTO 
 CONCAT OPERANDE 
 CONCAT OPERANDE 
 EQUAL 
 GOTO 
 CONCAT OPERANDE 
 CONCAT OPERANDE 
 EQUAL 
 GOTO 
 GOTO 
 GOTO 
 TAB[]EQUAL 
 TAB[]EQUAL 
 ECHO 
 ECHO 
 GOTO 
 EXIT 
 GOTO 

### Table of symbols : ###

n¬∞27421 : ID			Type : undefined	new_phrase
n¬∞29818 : ID			Type : int      	i
n¬∞70740 : ID			Type : undefined	mots
n¬∞72564 : ID			Type : undefined	nombre
n¬∞79937 : ID			Type : undefined	mot

Free Lglobal:


