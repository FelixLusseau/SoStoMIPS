    mot/id/entier:x
    =
    mot/id/entier:17
operande-> MOT
        crÃ©er quadOP:0  str:17
concatenation-> operande 
    ;
instruction-> ID = concatenation
[91mUpdating type of x to 1[0m
        crÃ©er quadOP:1  str:x
liste_instruction->instruction
        crÃ©er quadOP:2  cst:0
    while
M->empty
    test
    $
    {
    mot/id/entier:x
    }
operande-> $ { ID }
        crÃ©er quadOP:3  str:x
    -ne
operateur2-> -ne
    mot/id/entier:1
operande-> MOT
        crÃ©er quadOP:4  str:1
test_instruction-> operande operateur2 operande 
        crÃ©er quadOP:5  str:__TEMP__1
test_expr3 -> test_instruction 
test_expr2-> test_expr3 
2
3
    do
test_expr-> test_expr2 
test_bloc-> TEST test_expr 
M->empty
    mot/id/entier:r
    =
    $
    (
    expr
    $
    {
    mot/id/entier:x
    }
operande_entier-> $ { id } 
        crÃ©er quadOP:6  str:x
produit_entier-> operande_entier 
    %
    mot/id/entier:2
operande_entier-> ENTIER 
ToInt: 2
        crÃ©er quadOP:7  cst:2
produit_entier-> produit_entier fois_div_mod operande_entier
        crÃ©er quadOP:8  str:__TEMP__2
    )
somme_entiere-> produit_entier 
operande-> $ ( EXPR somme_entiere )
concatenation-> operande 
    ;
instruction-> ID = concatenation
[91mUpdating type of r to 1[0m
        crÃ©er quadOP:9  str:r
liste_instruction->instruction
        crÃ©er quadOP:10  cst:0
    case
    $
    {
    mot/id/entier:r
    }
operande-> $ { ID }
        crÃ©er quadOP:11  str:r
    in
    mot/id/entier:0
filtre->MOT
        crÃ©er quadOP:12  str:0
        crÃ©er quadOP:13  str:__TEMP__3
    )
M->empty
    mot/id/entier:x
    =
    $
    (
    expr
    $
    {
    mot/id/entier:x
    }
operande_entier-> $ { id } 
        crÃ©er quadOP:14  str:x
produit_entier-> operande_entier 
    /
    mot/id/entier:2
operande_entier-> ENTIER 
ToInt: 2
        crÃ©er quadOP:15  cst:2
produit_entier-> produit_entier fois_div_mod operande_entier
        crÃ©er quadOP:16  str:__TEMP__4
    )
somme_entiere-> produit_entier 
operande-> $ ( EXPR somme_entiere )
concatenation-> operande 
    ;
instruction-> ID = concatenation
        crÃ©er quadOP:17  str:x
liste_instruction->instruction
        crÃ©er quadOP:18  cst:0
    ;
liste_cas->filtre ) liste_instructions ; ; 
        crÃ©er quadOP:19  cst:12
        crÃ©er quadOP:20  cst:15
    mot/id/entier:1
filtre->MOT
        crÃ©er quadOP:21  str:1
        crÃ©er quadOP:22  str:__TEMP__5
    )
M->empty
    mot/id/entier:x
    =
    $
    (
    expr
    $
    {
    mot/id/entier:x
    }
operande_entier-> $ { id } 
        crÃ©er quadOP:23  str:x
produit_entier-> operande_entier 
    *
    mot/id/entier:3
operande_entier-> ENTIER 
ToInt: 3
        crÃ©er quadOP:24  cst:3
produit_entier-> produit_entier fois_div_mod operande_entier
        crÃ©er quadOP:25  str:__TEMP__6
    +
somme_entiere-> produit_entier 
    mot/id/entier:1
operande_entier-> ENTIER 
ToInt: 1
        crÃ©er quadOP:26  cst:1
produit_entier-> operande_entier 
    )
somme_entiere-> somme_entiere plus_ou_moin produit_entier 
        crÃ©er quadOP:27  str:__TEMP__7
operande-> $ ( EXPR somme_entiere )
concatenation-> operande 
    ;
instruction-> ID = concatenation
        crÃ©er quadOP:28  str:x
liste_instruction->instruction
        crÃ©er quadOP:29  cst:0
    ;
liste_cas->liste_cas filtre ) liste_instructions ; ; 
        crÃ©er quadOP:30  cst:18
        crÃ©er quadOP:31  cst:22
    esac
instruction-> CASE operande IN liste_cas ESAC 
liste_instruction->liste_instructions ; instruction
        crÃ©er quadOP:32  cst:0
    done
M->empty
instruction-> WHILE test_bloc DO liste_instructions DONE 
        crÃ©er quadOP:33  cst:6
        crÃ©er quadOP:34  cst:23
liste_instruction->liste_instructions ; instruction
        crÃ©er quadOP:35  cst:0
    ;
    exit
    mot/id/entier:0
operande_entier-> ENTIER 
ToInt: 0
        crÃ©er quadOP:36  cst:0
instruction->EXIT operande_entier
liste_instruction->liste_instructions ; instruction
        crÃ©er quadOP:37  cst:0
    ;
    exit
instruction->EXIT
liste_instruction->liste_instructions ; instruction
        crÃ©er quadOP:38  cst:0
programme->liste_instruction

Affichage Lglobal:
ligne 1:  res: id:x  EQUAL  op1: string:17  op2: NULL 
ligne 2:  res: addr:3  GOTO  op1: NULL  op2: NULL 
ligne 3:  res: id:__TEMP__1  IF !=  op1: id:x  op2: string:1 
ligne 4:  res: addr:6  IF _ GOTO  op1: id:__TEMP__1  op2: NULL 
ligne 5:  res: addr:23  GOTO  op1: NULL  op2: NULL 
ligne 6:  res: id:__TEMP__2  MOD  op1: id:x  op2: cst:2 
ligne 7:  res: id:r  EQUAL  op1: id:__TEMP__2  op2: NULL 
ligne 8:  res: addr:9  GOTO  op1: NULL  op2: NULL 
ligne 9:  res: id:__TEMP__3  IF ==  op1: id:r  op2: string:0 
ligne 10:  res: addr:12  IF _ GOTO  op1: id:__TEMP__3  op2: NULL 
ligne 11:  res: addr:15  GOTO  op1: NULL  op2: NULL 
ligne 12:  res: id:__TEMP__4  DIV  op1: id:x  op2: cst:2 
ligne 13:  res: id:x  EQUAL  op1: id:__TEMP__4  op2: NULL 
ligne 14:  res: addr:15  GOTO  op1: NULL  op2: NULL 
ligne 15:  res: id:__TEMP__5  IF ==  op1: id:r  op2: string:1 
ligne 16:  res: addr:18  IF _ GOTO  op1: id:__TEMP__5  op2: NULL 
ligne 17:  res: addr:22  GOTO  op1: NULL  op2: NULL 
ligne 18:  res: id:__TEMP__6  MUL  op1: id:x  op2: cst:3 
ligne 19:  res: id:__TEMP__7  ADD  op1: id:__TEMP__6  op2: cst:1 
ligne 20:  res: id:x  EQUAL  op1: id:__TEMP__7  op2: NULL 
ligne 21:  res: addr:22  GOTO  op1: NULL  op2: NULL 
ligne 22:  res: addr:3  GOTO  op1: NULL  op2: NULL 
ligne 23:  res: addr:24  GOTO  op1: NULL  op2: NULL 
ligne 24:  res: cst:0  EXIT  op1: NULL  op2: NULL 
ligne 25:  res: addr:26  GOTO  op1: NULL  op2: NULL 
ligne 26:  res: NULL  EXIT  op1: NULL  op2: NULL 
ligne 27:  res: addr:28  GOTO  op1: NULL  op2: NULL 
Yacc return : ->0

### MIPS: ###

 EQUAL 
 GOTO 
 IF != 
 IF _ GOTO 
 GOTO 
 MOD 
 EQUAL 
 GOTO 
 IF == 
 IF _ GOTO 
 GOTO 
 DIV 
 EQUAL 
 GOTO 
 IF == 
 IF _ GOTO 
 GOTO 
 MUL 
 ADD 
 EQUAL 
 GOTO 
 GOTO 
 GOTO 
 EXIT 
 GOTO 
 EXIT 
 GOTO 

Free Lglobal:


